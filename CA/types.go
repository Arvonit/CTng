package CA

import (
	"CTng/gossip"
	"CTng/crypto"
	"CTng/util"
	"CTng/config"
	//"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"crypto/x509"
	//"log"
	"net/http"
	//"time"
	"crypto/rsa"
	"crypto/rand"
	//"strings"
	//"strconv"
	//"bytes"
	//"github.com/gorilla/mux"
)

type CAContext struct {
	Client            *http.Client
	SerialNumber      int
	CA_public_config  *CA_public_config
	CA_private_config *CA_private_config
	CA_crypto_config *crypto.CryptoConfig
	PublicKey		 rsa.PublicKey
	PrivateKey		 rsa.PrivateKey
	CurrentCertificatePool   *CertPool
	CertPoolStorage   *CTngCertPoolStorage
	Rootcert *x509.Certificate
	CertCounter int
	CRV *CRV
	CA_Type int //0 for normal CA, 1 for Split-world CA, 2 for always unreponsive CA, 3 for sometimes unreponsive CA
	Request_Count int //Only used for sometimes unreponsive CA and Split-world CA
	REV_storage map[string]gossip.Gossip_object //for monitor to query
	REV_storage_fake map[string]gossip.Gossip_object //for monitor to query
	MisbehaviorInterval int //for sometimes unreponsive CA and Split-world CA, misbehave every x requests
}

type CA_public_config struct {
	All_CA_URLs     []string
	All_Logger_URLs []string
	MMD             int
	MRD             int
	Http_vers       []string
}


type CA_private_config struct {
	Signer                 string
	Port                   string
	Loggerlist 		       []string
	Monitorlist 		   []string
	Gossiperlist 		   []string
	Cert_per_period        int
}

type ProofOfInclusion struct {
	SiblingHashes [][]byte
	NeighborHash  []byte
}


type POI struct {
	ProofOfInclusion ProofOfInclusion
	SubjectKeyId     string
}

//RID is self generated by the CA
type CTngExtension struct{
	STH gossip.Gossip_object `json:"STH,omitempty"` // STH is the Signed Tree Head of the CT log
	POI ProofOfInclusion `json:"POI,omitempty"` // POI is the proof of inclusion of the certificate in the CT log
	RID int `json:"RID"` 
}

type CTngCertPoolStorage struct{
	Certpools map[string] CertPool
}

// add CTngExtension to a certificate
func AddCTngExtension(cert *x509.Certificate, ctngext CTngExtension) *x509.Certificate {
	// use CRLDistributionPoints to store the CTngExtension
	// encode the ctngext to bytes using json marshal indent
	ctngextbytes, err := json.MarshalIndent(ctngext, "", "  ")
	if err != nil {
		fmt.Println("Error in AddCTngExtension: ", err)
	}
	// encode the bytes to string
	ctngextstr := string(ctngextbytes)
	// add the ctngext to the cert
	cert.CRLDistributionPoints = append(cert.CRLDistributionPoints, ctngextstr)
	return cert
}

// get all ctng extensions from a certificate
func GetCTngExtensions(cert *x509.Certificate) []CTngExtension {
	// use CRLDistributionPoints to store the CTngExtension
	var ctngexts []CTngExtension
	for _, ext := range cert.CRLDistributionPoints {
		var ctngext CTngExtension
		// convert the string to bytes
		ctngextbytes := []byte(ext)
		// decode the bytes to ctngext
		err := json.Unmarshal(ctngextbytes, &ctngext)
		if err != nil {
			fmt.Println("Error in GetCTngExtensions: ", err)
		}
		ctngexts = append(ctngexts, ctngext)
	}
	return ctngexts
}

func GetPrecertfromCert(cert *x509.Certificate) *x509.Certificate {
	// only keep the first ctng extension in CRLDistributionPoints
	var ctngext CTngExtension
	fmt.Sscanf(cert.CRLDistributionPoints[0], "%v", &ctngext)
	cert.CRLDistributionPoints = []string{fmt.Sprintf("%v", ctngext)}
	return cert
}

// Generate a CA public config template
func GenerateCA_public_config_template() *CA_public_config {
	return &CA_public_config{
		All_CA_URLs:     []string{},
		All_Logger_URLs: []string{},
		MMD:             0,
		MRD:             0,
		Http_vers:       []string{},
	}
}
// Generate a CA Crypto config template
func GenerateCA_Crypto_config_template() *crypto.StoredCryptoConfig {
	return &crypto.StoredCryptoConfig{
		SelfID: crypto.CTngID("0"),
		Threshold: 0,
		N: 0,
		HashScheme: 0,
		SignScheme: "",
		ThresholdScheme: "",
		SignaturePublicMap: crypto.RSAPublicMap{},
		RSAPrivateKey: rsa.PrivateKey{},
		ThresholdPublicMap: map[string][]byte{},
		ThresholdSecretKey: []byte{},
	}
}

// Generate a CA private config template
func GenerateCA_private_config_template() *CA_private_config {
	return &CA_private_config{
		Signer:                 "",
		Port:                   "",
		Loggerlist:             []string{},
		Monitorlist:            []string{},
		Gossiperlist:           []string{},
		Cert_per_period:        0,
	}
}


// Generate a public key from a private key
func publicKey(priv *rsa.PrivateKey) rsa.PublicKey {
	return priv.PublicKey
}
// Gererate RSA key pair
func GenerateRSAKeyPair() (rsa.PrivateKey, rsa.PublicKey) {
	priv, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Println("rsa keygen failed")
	}
	pub := publicKey(priv)
	return *priv,pub
}

// write a CA private config or ca public config or crypto config to file
func WriteConfigToFile(config interface{}, filepath string) {
	util.CreateFile(filepath)
	// file name should be "CA_private_config.json" or "CA_public_config.json" or "CA_crypto_config.json" depending on the config type
	filename := filepath + fmt.Sprintf("%T.json", config)
	jsonConfig, err := json.Marshal(config)
	if err != nil {
		fmt.Println("json marshal failed")
	}
	err = ioutil.WriteFile(filename, jsonConfig, 0644)
	if err != nil {
		fmt.Println("write file failed")
	}
}

// initialize CA context
func InitializeCAContext(public_config_path string,private_config_file_path string,crypto_config_path string) *CAContext{
	// Load public config from file
	pubconf := new(CA_public_config)
	config.LoadConfiguration(&pubconf, public_config_path)
	// Load private config from file
	privconf := new(CA_private_config)
	config.LoadConfiguration(&privconf, private_config_file_path)
	// Load crypto config from file
	cryptoconfig, err := crypto.ReadCryptoConfig(crypto_config_path)
	if err != nil {
		//fmt.Println(err)
	}
	// Initialize CA Context
	caContext := &CAContext{
		SerialNumber: 0,
		CA_public_config: pubconf,
		CA_private_config: privconf,
		CA_crypto_config: cryptoconfig,
		PublicKey:  cryptoconfig.SignaturePublicMap[cryptoconfig.SelfID],
		PrivateKey: cryptoconfig.RSAPrivateKey,
		CurrentCertificatePool: NewCertPool(),
		CertPoolStorage: &CTngCertPoolStorage{Certpools: make(map[string] CertPool)},
		CA_Type: 0,
		Request_Count: 0,
		REV_storage:  make(map[string]gossip.Gossip_object),
		REV_storage_fake: make(map[string]gossip.Gossip_object),
		MisbehaviorInterval: 0,
	}
	// Initialize http client
	tr := &http.Transport{}
	caContext.Client = &http.Client{
		Transport: tr,
	}
	// Generate root certificate
	caContext.Rootcert = Generate_Root_Certificate(caContext)
	newCRV := CRV_init()
	caContext.CRV = newCRV
	return caContext
}

